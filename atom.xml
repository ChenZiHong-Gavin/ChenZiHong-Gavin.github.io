<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈氏小屋</title>
  
  <subtitle>这里有我想说的</subtitle>
  <link href="http://chenzihong.com/atom.xml" rel="self"/>
  
  <link href="http://chenzihong.com/"/>
  <updated>2020-12-22T03:16:20.371Z</updated>
  <id>http://chenzihong.com/</id>
  
  <author>
    <name>陈子鸿</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>宏观经济学</title>
    <link href="http://chenzihong.com/2020/12/19/Economic%20Principles/"/>
    <id>http://chenzihong.com/2020/12/19/Economic%20Principles/</id>
    <published>2020-12-19T10:54:56.000Z</published>
    <updated>2020-12-22T03:16:20.371Z</updated>
    
    <content type="html"><![CDATA[<p>宏观经济学可以解释这些问题：</p><ol><li>为什么一些国家平均收入高，而一些国家平均收入低？</li><li>为什么物价有时候上涨迅速，有时候比较稳定？</li><li>为什么生产和就业在一些时候扩张，在另一些时候收缩？</li></ol><h2><span id="一国收入的衡量">一国收入的衡量</span></h2><p>国内生产总值，即GDP，被认为是衡量社会经济福利最好的一个指标。</p><h3><span id="经济的收入与支出">经济的收入与支出</span></h3><p>当你判断一个人在经济上是否成功的时候，你会看他的收入。同样的道理适用于一个国家的整体经济。当判断一个国家是富裕还是贫穷的时候，会考察经济中所有人的总收入，这就是<strong>国内生产总值</strong>。</p><blockquote><p>GDP同时衡量两件事：经济中所有人的总收入和用于经济中物品与服务产出的总支出。</p><p>因为对于一个整体经济而言，收入必定等于支出。</p></blockquote><h3><span id="国内生产总值的衡量">国内生产总值的衡量</span></h3><blockquote><p>定义：</p><p><strong>国内生产总值</strong>，GDP，在某一既定时期一个国家内生产的所有最终物品与服务的市场价值。</p></blockquote><ul><li>所谓“市场价值”：GDP要把许多种不同的物品加总为一个经济活动价值的衡量指标，为了这样做，它使用了市场价格。市场价格衡量人们愿意为各种不同物品支付的量，市场价格反映了这些物品的市场价值。</li><li>所谓“所有”：GDP是全面的衡量指标。它包括在经济中生产并在市场中合法出售的所有东西。但是GDP不包括非法生产和销售的东西，比如毒品。GDP也不包括家庭内生产和消费并且没有进入市场的东西。</li><li>所谓“最终”：GDP只包括最终产品的价值，因为中间物品的价值已经包括在最终物品的价格中了。</li><li>所谓“物品与服务”：GDP既包括有形的物品，又包括无形的服务</li><li>所谓“生产的”：GDP不包括已经生产的物品的交易。比如当一个人把一辆二手车出售给另一个人，那么这辆车的价值不包括在GDP里面。</li><li>所谓“在某一特定时期”：这个时期一般是一个季度或者一年。</li></ul><h3><span id="gdp的组成部分">GDP的组成部分</span></h3><p>GDP（Y）被分为4个部分：消费（C）、投资（I）、政府购买（G）、净出口（NX）。</p><script type="math/tex; mode=display">Y=C+I+G+NX</script><ol><li><p>消费</p><p><strong>消费</strong>是家庭除了购买新住房之外用于物品和服务的支出。</p><p>家庭用于教育的支出也包括在服务里面。</p></li><li><p>投资</p><p><strong>投资</strong>是用于未来生产更多物品和服务的物品的购买。</p><p>它是资本设备、存货和建筑物购买的总和。</p><p>所以住房的购买不是属于消费而是属于投资。</p></li><li><p>政府购买</p><p>政府购买是政府用于物品与服务的支出。</p><p>如果政府向老年人支付社会保障补助，或者向失业的人支付补助，这些支出叫做<strong>转移支付</strong>，不包括在政府购买之中。因为转移支付改变了家庭收入，但是并不反映生产与消费水平。</p></li><li><p>净出口</p><p><strong>净出口</strong>等同于外国对国内生产的物品的购买减去国内对于外国物品的购买。</p></li></ol><h3><span id="真实gdp与名义gdp">真实GDP与名义GDP</span></h3><p>随着时间的变化，市场中物品的价格会有波动。如果想要衡量不受物品和服务价格变动影响所生产的物品与服务的总量，可以引入<strong>真实GDP</strong>。</p><p>一个例子：</p><div class="table-container"><table><thead><tr><th>年份</th><th>热狗价格</th><th>热狗产量</th><th>汉堡包价格</th><th>汉堡包产量</th></tr></thead><tbody><tr><td>2013</td><td>1</td><td>100</td><td>2</td><td>50</td></tr><tr><td>2014</td><td>2</td><td>150</td><td>3</td><td>100</td></tr><tr><td>2015</td><td>3</td><td>200</td><td>4</td><td>150</td></tr></tbody></table></div><p>名义GDP：</p><div class="table-container"><table><thead><tr><th>年份</th><th>GDP</th></tr></thead><tbody><tr><td>2013</td><td>200</td></tr><tr><td>2014</td><td>600</td></tr><tr><td>2015</td><td>1200</td></tr></tbody></table></div><p>真实GDP（以2013年为基年）：</p><div class="table-container"><table><thead><tr><th>年份</th><th>GDP</th></tr></thead><tbody><tr><td>2013</td><td>200</td></tr><tr><td>2014</td><td>350</td></tr><tr><td>2015</td><td>500</td></tr></tbody></table></div><blockquote><p>真实GDP是按不变价格评价的物品与服务的生产。</p><p>计算真实GDP的时候，通常会指定一年作为基年，然后用这年的物品与服务的价格计算GDP。</p></blockquote><p>名义GDP是用当年价格来评价经济中物品与服务生产的价值。</p><p>真实GDP是用不变的基年价格来评价经济中物品与服务生产的价值。</p><p>a</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;宏观经济学可以解释这些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么一些国家平均收入高，而一些国家平均收入低？&lt;/li&gt;
&lt;li&gt;为什么物价有时候上涨迅速，有时候比较稳定？&lt;/li&gt;
&lt;li&gt;为什么生产和就业在一些时候扩张，在另一些时候收缩？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;sp</summary>
      
    
    
    
    <category term="Economics" scheme="http://chenzihong.com/categories/Economics/"/>
    
    
    <category term="Economics - Macroeconomics" scheme="http://chenzihong.com/tags/Economics-Macroeconomics/"/>
    
  </entry>
  
  <entry>
    <title>计算机组织与结构</title>
    <link href="http://chenzihong.com/2020/12/08/COA/"/>
    <id>http://chenzihong.com/2020/12/08/COA/</id>
    <published>2020-12-07T16:00:00.000Z</published>
    <updated>2020-12-21T01:04:46.214Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="computer-organization-and-architecture">Computer Organization and Architecture</span></h1><h2><span id="introduction">Introduction</span></h2><p>计算机不再是帮助我们执行程序的黑盒，可以对计算机系统功能部件有基本的了解。</p><h3><span id="计算机">计算机</span></h3><blockquote><p>计算机全称为”通用电子数字计算机”。</p></blockquote><ul><li>通用：非专一设备。任何计算机在给予足够时间和容量存储器的条件下，可以完成相同的运算。</li><li>电子：由电子元器件而非机械器件组成。</li><li>数字：信息采用数字化形式表示。</li></ul><blockquote class="pullquote mindmap mindmap-md"><ul><li>计算机系统<ul><li>硬件<ul><li>处理器</li><li>存储器</li><li>外部设备</li></ul></li><li>软件<ul><li>程序</li><li>文档</li></ul></li></ul></li></ul></blockquote><h3><span id="组织与结构">组织与结构</span></h3><ul><li>结构</li></ul><p>对程序员可见，这些属性直接影响到程序的逻辑执行。</p><p>例如：指令集、表示各种数据类型的比特数、输入输出机制、内存寻址技术。</p><ul><li>组织</li></ul><p>对程序员不可见，实现计算机结构规范的操作单元以及其相互连接。</p><p>例如：控制信号、计算机和外设的接口、存储器使用的技术。</p><hr><p>结构上实现补码乘法运算：repeated addition</p><p>组织上实现补码乘法运算：a hardware unit</p><hr><h3><span id="功能与组成">功能与组成</span></h3><ul><li><p>功能</p><ul><li>数据处理</li><li>数据存储</li><li>数据传送</li><li>控制</li></ul></li><li><p>组成</p><ul><li><strong>中央处理单元</strong>（CPU）：控制计算机的操作并完成数据处理。<ul><li>控制器：控制CPU乃至整个计算机的操作。</li><li>算数逻辑单元（ALU）：数据处理。</li><li>寄存器：为CPU提供内部存储。</li><li>CPU内部互连：控制器、ALU、寄存器之间的通信。</li></ul></li><li><strong>主存储器</strong>：存储数据。</li><li><strong>I/O</strong>：在计算机与外部设备之间传送数据。</li><li>系统互连：为CPU、主存、I/O之间提供通信机制。</li></ul></li></ul><h3><span id="计算机简史">计算机简史</span></h3><ul><li><p>1946-1957：真空管</p><ul><li>ENAC：十进制、手动编程、通过设置开关和插拔电缆头实现</li><li>冯诺依曼机：二进制、可存储</li></ul></li></ul><blockquote class="pullquote mindmap mindmap-md"><ul><li>冯诺依曼机器<ul><li>CPU<ul><li>处理单元</li><li>控制单元</li><li>存储器</li></ul></li><li>I/0</li><li>输入设备</li><li>输出设备</li></ul></li></ul></blockquote><ul><li>1958-1964：晶体管<ul><li>晶体管比电子管体积小、更便宜、发热少。</li><li>第二代计算机采用了更复杂的算数逻辑单元和控制器，使用了高级编程语言。</li></ul></li><li>1965-今天：集成电路<ul><li>将整个电路安装在很小的硅片上而不是分立元件搭成的等价电路。</li></ul></li></ul><blockquote><p><strong>摩尔定律</strong>：</p><p>The number of transistors that could be put on a single chip is  doubling every year (1965-1969) / 18 months (1970-now)</p></blockquote><p>影响：</p><ol><li>单个芯片的成本几乎没有变化，所以计算机逻辑电路和存储器电路的成本显著下降。</li><li>集成度更高，电路长度更短，提高了工作速度。</li><li>计算机可以变得更小。</li><li>减少电能的消耗和对冷却的要求。（也许是因为3）</li><li>集成电路内部的连接比芯片之间的焊接更加可靠。</li></ol><h3><span id="计算机的性能">计算机的性能</span></h3><ul><li><p>性能衡量标准</p><ul><li>CPU：速度</li><li>Memory：容量、速度</li><li>I/O：容量、速度</li></ul></li><li><p>系统时钟</p><ul><li>时钟频率/时钟速率（单位：HZ）：计算机执行其最基本操作的基本速率，以每秒周期为单位</li><li>时钟周期：CPU的一次电子脉冲</li><li>周期时间：脉冲之间的时间间隔</li></ul></li><li><p>指令的执行时间计算</p><ul><li>处理器被一个有着恒定频率$f$或者说，恒定周期时间$t$的时钟驱动</li><li>设$CPI_i$是类型$i$种指令要执行的周期数量，$I_i$是在给定的程序中，类型$i$的指令数量。</li><li>CPI（平均执行周期数）：计算机平均执行一条指令所需的时钟周期数</li></ul><script type="math/tex; mode=display">CPI=\Sigma_{i=1}^n \frac{CPI_i×I_i}{I_c} \\I_c=\Sigma_{i=1}^nI_i</script><ul><li>执行程序的时间计算</li></ul><script type="math/tex; mode=display">𝑇 = 𝐼_𝑐 × 𝐶𝑃𝐼 × 𝑡</script><ul><li>Million Instructions Per Second (MIPS速率)：每秒处理的百万级的<a href="https://baike.baidu.com/item/机器语言/2019225">机器语言</a>指令数</li></ul><script type="math/tex; mode=display">𝑀𝐼𝑃𝑆 =\frac{𝐼_𝑐}{𝑇 × 10^6}=\frac{𝑓}{𝐶𝑃𝐼 × 10^6}</script><ul><li>Million Floating-point Operations per Second (MFLOPS)：每秒百万个<a href="https://baike.baidu.com/item/浮点">浮点</a>操作，衡量计算机系统的技术指标，不能反映整体情况，只能反映浮点运算情况。</li></ul></li></ul><script type="math/tex; mode=display">MFLOPS=\frac{操作浮点数}{执行时间*10^6}</script><ul><li><p>性能标准</p><ul><li>Measure the performance of systems using a set of benchmark<br>programs<ul><li>平均水平: <ul><li>算数平均数: </li><li>几何平均数：</li></ul></li></ul></li></ul><script type="math/tex; mode=display">R_A=\frac{1}{m}\Sigma_{i=1}^mR_i \\R_H=\frac{m}{\Sigma_{i=1}^mR_i}</script></li></ul><h2><span id="a-top-level-view-of-computer-function-and-interconnection">A Top-Level View of Computer Function and Interconnection</span></h2><h3><span id="计算机部件">计算机部件</span></h3><p>冯诺依曼结构基于以下概念：</p><ol><li>数据和指令存储在单一的读写存储器中</li><li>存储器的内容可以通过位置寻址，而不考虑它的数据类型是什么</li><li>依顺序的形式从一条指令到下一条指令</li></ol><ul><li>CPU</li></ul><blockquote><p>问题：</p><p>CPU在等待I/O设备时保持空闲</p><p>解决办法：</p><p>采用中断机制</p></blockquote><ul><li>Memory(内存)：</li></ul><p>内存模块包括一组单元，由连续的编号来定义地址。每个单元都有一个二进制数，它既可以解释为指令也可以解释为数据。    </p><blockquote><p>问题：</p><p>主存和CPU之间数据传输的速度难以跟上CPU处理数据的速度。</p><p>解决方法：</p><ul><li>添加cache或者其它数据缓冲的方法，减少内存访问的频率，增加数据传输率</li><li>增加内存一次检索的位数</li></ul></blockquote><p>对内存的要求：</p><ol><li>存储数据需要大容量</li><li>提高性能需要传输速度</li></ol><p>因此，我们采用内存分层结构。</p><p><img src="/medias/articleimages/COA_1.png" alt="hiercle"></p><ul><li><p>I/O：在CPU、内存与外部设备之间交换数据</p><blockquote><p>问题：</p><p>I/O的性能跟不上CPU速度的增加。</p><p>解决办法：</p><ol><li>缓存</li><li>采用新的接口技术</li></ol></blockquote><ul><li>BUS(总线)：连接两个或者更多设备的一种方式<ul><li>数据线：在系统模块之间移动数据</li><li>地址线：指定数据总线上的数据和地址I/O端口</li><li>控制线：控制数据的访问和使用</li></ul></li></ul></li></ul><h3><span id="计算机部件的功能与协作">计算机部件的功能与协作</span></h3><h2><span id="integer-floating-point-and-decimal-representation">Integer, Floating-point and Decimal Representation</span></h2><h3><span id="算数逻辑单元alu">算数逻辑单元（ALU）</span></h3><p>算数逻辑单元是计算机实际完成数据算数和逻辑运算的部分。算数逻辑单元以及计算机的所有电子部件都是基于简单数字逻辑装置的使用，这些装置能保存二进制数和完成简单的布尔运算。</p><ul><li>数据由寄存器提交给ALU</li><li>ALU设置标志作为运算结果，如上溢标志</li><li>标志值也存于CPU内的寄存器中</li></ul><h3><span id="整数表示">整数表示</span></h3><p>为了表示出多个数值，必须对多个位进行组合。如果有k位，最多能区分出$2^k$个不同的值。</p><ul><li><p>无符号整数</p><p>对于计算机的存储，符号和小数点是不方便的。若我们只使用非负整数，那么表示方法是直截了当的。例如一个8位的字能表示0-255。</p></li></ul><script type="math/tex; mode=display">00000000=0 \\00000001=1 \\10000000=128 \\11111111=255</script><p>​    通常，若以一个n位二进制数字序列$a<em>n a</em>{n-1} \cdots a_1 a_0$表示一个无符号整数A，那么</p><script type="math/tex; mode=display">A=\Sigma_{i=0}^{n-1}2^ia_i</script><ul><li><p>符号-幅值表示</p><p>以一个n位字为例，最左边是符号位，其余n-1为整数的幅值</p><ul><li>缺点<ul><li>加减时需要考虑符号位</li><li>0有两种表示方法</li></ul></li></ul></li><li><p>补码表示法</p><ul><li><p>算数特点</p><ul><li>范围：$-2^{n-1}-2^{n-1}-1$</li><li>表示0的个数：1个</li><li><p>取负：取反加一</p></li><li><p>位长度拓展：在左边添加需要拓展长度的符号位</p></li></ul></li></ul></li><li><p>上溢规则：当两个同符号数相加，符号位发生改变时发生上溢</p></li><li><p>2的补码</p><script type="math/tex; mode=display">A=-2^{n-1}a_{n-1}+\Sigma_{i=0}^{n-2}2^ia_i</script></li></ul><h3><span id="浮点数表示">浮点数表示</span></h3><ul><li><p>科学计数法</p><script type="math/tex; mode=display">\pm S×B^{\pm E}</script><p>$\pm$：正或负</p><p>S：有效数</p><p>B：base，无需存储因为它对所有数字都一样</p><p>E：指数</p><p><img src="/medias/articleimages/COA_2.png" alt="floating-point"></p></li><li><p>标准形式</p><script type="math/tex; mode=display">\pm 1.bb…b×2^{\pm E}</script><ul><li>第一位存取符号位</li><li>有效数的第一位永远是1，不需要存储</li><li>指数加上127存储到指数位</li><li>基底是2</li></ul></li><li><p>取值范围</p><script type="math/tex; mode=display">负数：-(2-2^{-23})×2^{128}—-2^{-127} \\正数：2^{-127}—(2-2^{-23})×2^{128}</script></li><li><p>在范围和精度之间有一个权衡</p><ul><li>增加指数位：范围变大，精度变小</li><li>增加有效数字的位数：精度变大，可表示数字的范围变小</li></ul></li><li>IEEE Standard 754<ul><li>0指数和0分数一起表示正零与负零，取决于它的符号位</li><li>全1指数和0分数一起表示正无穷大或负无穷大没取决于它的符号位</li><li>0指数与非0分数表示反规格数，小数点左边的隐藏位是0</li><li>全1指数与非0分数一起给出NaN值，表示不是一个数字</li></ul></li></ul><h3><span id="十进制表示法">十进制表示法</span></h3><p>​    用四位Binary-Coded Decimal表示0,1,2,3,4……9，直接运算</p><script type="math/tex; mode=display">0:0000 \\1:0001 \\\vdots \\9:1001</script><p>Sign：</p><script type="math/tex; mode=display">正：1100/0 \\负：1101/1</script><p>Example：</p><script type="math/tex; mode=display">+2039: 1100 \ 0010\  0000\  0011\  1001 / 0\  0010\  0000\  0011\  1001 \\-1265: 1101\  0001\  0010\  0110\  0101 / 1\  0001\  0010\  0110\  0101</script><h3><span id="整数运算以补码表示为标准">整数运算（以补码表示为标准）</span></h3><ul><li><p>取负</p><ol><li>将整数的每一位取反</li><li>将此结果作为一个无符号数对待，加一</li></ol><p>特殊情况：</p><ol><li>考虑A=0</li></ol><script type="math/tex; mode=display">0=00000000 \\取反=11111111 \\加一=100000000</script><p>​    不需要考虑向上进位，因此，0取负还是0</p><ol><li>考虑A=-128=10000000</li></ol><script type="math/tex; mode=display">取反=01111111 \\加一=10000000=-128</script><p>无法避免的错误：一个n位字无法表示$2^n$</p></li><li><p>加法和减法</p><ul><li><p>上溢规则：两个数相加，若它们同为正数或者同为负数，当且仅当结果的符号位变为相反时才出现上溢</p></li><li><p>加法器的原理：</p><p>中心元件是一个二进制加法器，它对提交的两个数相加，产生一个和数和一个上溢指示</p></li></ul></li></ul><blockquote><p>全加器(Full Adder：用<a href="https://baike.baidu.com/item/门电路/10796427">门电路</a>实现两个二进制数相加并求出和的组合线路</p></blockquote><ul><li>全加器真值表</li></ul><div class="table-container"><table><thead><tr><th>输入</th><th>输入</th><th>输入</th><th>输出</th><th>输出</th></tr></thead><tbody><tr><td>Ci-1</td><td>Ai</td><td>Bi</td><td>Si</td><td>Ci</td></tr><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>一位全加器的表达式如下：</p><script type="math/tex; mode=display">S_i=A_i⊕B_i⊕C_{i-1} \\C_i=A_iB_i+C_{i-1}(A_i+B_i) \\</script><p>第二个表达式也可用一个异或门来代替或门对其中两个输入信号进行求和</p><ul><li><p>乘法</p><ul><li><p>无符号整数的乘法 X × Y</p><ul><li>如果Yi是0，结果为0，否则结果为X</li><li>每一步都将计算结果左移</li><li>将所有结果相加</li></ul><blockquote><p>与手算相比，计算机可以简化以下几个步骤：</p><ol><li>可以边产生部分积边做加法</li><li>可以节省某些部分积的生成时间</li></ol></blockquote></li><li><p>补码乘法</p><p>被乘数与乘数只要有一个是负数，那么无符号整数的乘法就无法适用</p><ul><li>布思算法</li></ul></li></ul></li></ul><script type="math/tex; mode=display">X×Y=X× Y_nY_{n-1}\cdots Y_2Y_1 \\=X×(-Y_n×2^{n-1}+Y_{n-1}×2^{n-2}+ \cdots +Y_2*2^1+Y_1*2^0) \\=2^n×\Sigma_{i=0}^{n-1}(X×(Y_i-Y_{i+1})×2^{-(n-i)})</script><p>​                        布思算法的步骤：</p><ol><li>$Y_0=0$</li><li>根据$Y_{i+1} Y_i$，决定加+X，-X，+0</li><li>右移部分积</li><li>重复步骤二和步骤三n次，直到得到最终结果</li></ol><ul><li><p>取模运算</p><p>首先，看看自然数的取模运算（<strong>定义1</strong>）:</p><blockquote><p>如果<em>a</em>和<em>d</em>是两个自然数，<em>d</em>非零，可以证明存在两个唯一的整数 <em>q</em> 和 <em>r</em>，满足 <em>a</em> = <em>qd</em> + <em>r</em> 且0 ≤ <em>r</em> &lt; <em>d</em>。其中，<em>q</em> 被称为商，<em>r</em> 被称为余数。</p></blockquote><p>对于整数：</p><blockquote><p>如果<em>a</em> 与<em>d</em> 是<strong>整数</strong>，<em>d</em> 非零，那么<strong>余数</strong>r 满足这样的关系：</p><p>a = qd + r , q 为整数，且0 ≤ |r| &lt; |d|。</p></blockquote></li></ul><p>算法：</p><ol><li>如果被除数与除数符号相同，用被除数减去一定倍数的除数，不使其变号</li><li>如果被除数与除数符号不同，用被除数加上一定倍数的除数，不使其变号</li></ol><ul><li><p>除法</p><p>特殊情况：</p><ol><li>X为0，Y不为0: 0</li><li>X不为0，Y为0：exception</li><li>X为0，Y为0：nan</li><li>X不为0，Y不为0：进行运算</li></ol><p>过程：</p><ol><li>除数被装入M寄存器，被除数被装入Q寄存器，被除数必须以2n位的补码来表示。（算术拓展），余数被装入A寄存器。</li><li>A，Q左移一位</li><li>若M与A同符号，A变成A-M，否则A变成A+M</li><li>若A在操作后符号没有改变，则上述操作是成功的</li><li>如果操作是成功的或者A=0，则Q0=1；如果操作是不成功的，Q0=0并恢复之前A的值</li><li>重复2-4，Q有多少位就执行多少步</li><li>最后A中的是余数，如果被除数与除数同号，那么Q中的是商，否则Q中的值取负为正确的商</li></ol></li><li><p>位移</p><blockquote><p>根据标准i386手册(p384)，所有shift操作的移位操作数仅使用后5位，其他位数直接舍去</p></blockquote><ul><li>逻辑左移：右边添0</li><li>算术左移：右边添0</li><li>逻辑右移：左边添0</li><li>算术右移：添加符号位</li><li>循环左移</li><li>循环右移</li></ul></li></ul><h3><span id="浮点数运算">浮点数运算</span></h3><ul><li><p>几种问题：</p><ol><li>指数上溢：一个正指数超出了最大允许的指数值</li><li>指数下溢：一个负指数小于最小允许的指数值</li><li>有效数下溢：有效数对齐时，右端有数字丢失</li><li>有效数上溢：两个有效数相加有进位</li></ol></li><li><p>浮点数加法与减法</p><p>四个阶段：</p><ol><li>检查0： 如果一个操作数是0，那么另一个操作数就是结果</li><li>对齐有效数： 操纵数使两个指数相等。一般来说，右移较小的数字所造成的损失较小。若此过程造成的有效数是0，那么另一个数为结果，即两个数指数相差较大，则丢失较小的那一个数</li><li>加法：两个有效数相加，包括它们的符号一起考虑。这里可能发生上溢，则有效数右移，指数增量，若指数发生上溢，那么应该停止该操作并且报告。</li><li>规格化：左移有效数到最高有效数字，此过程中，指数可能下溢，应该停止操作并报告</li></ol></li><li><p>保护位</p><p>在浮点运算之前，每个操作数的指数和有效数都要装进ALU的寄存器中。有效数装入的情况是，寄存器的长度几乎总是大于有效位长加一个隐藏位之和，其余附加位叫做保护位。用于以0扩展有效位的右端。</p></li><li><p>浮点数乘法</p><ol><li>考虑极端情况</li><li>判断是否有数为0</li><li>指数相加</li><li>有效数相乘</li><li>规格化有效数（可能导致指数溢出）</li></ol></li></ul><h3><span id="decimal加减法">Decimal加减法</span></h3><ul><li><p>加法</p><p>当有值在10到19之间时，需要进位</p></li><li><p>减法</p><p>加上补码</p></li></ul><h2><span id="cache">Cache</span></h2><p>Cache是一种内存储器</p><h3><span id="cache存储器原理">Cache存储器原理</span></h3><p>Cache的目的是，为了给出逼近最快存储器的速度，同时用较便宜的半导体存储器的价格提供一个大的存储器容量。</p><p>当CPU试图从存储器中读取一个字时，检查这个字是否在Cache中，如果是，则这个字传送给CPU，如果不是，则主存储器中国一块固定数字的字被读入Cache。</p><p>由于访问局部性，当把一块数据存入Cache，将来CPU访问其它字是有可能的</p><h3><span id="结构">结构</span></h3><ul><li>主存储器由多达$2^n$个可寻址的字组成，每个字都有唯一的n位地址</li><li>我们可以把这个存储器看成由许多定长的块组成，每个块有K个字，即有M=2^n/K个块</li><li>Cache有C个行组成，每行有K个字，行的数量远远小于块的数量</li><li>每行有个标记，用来识别当前存储的是哪一个块</li><li>这个标记通常是主存储器地址的一部分</li></ul><h3><span id="读操作">读操作</span></h3><ol><li>处理器产生一个要读取的字的地址RA</li><li>如果这个字存在于Cache中，则返回这个字</li><li>否则，进行两个并行操作：<ol><li>把包含这个字的块装进Cache</li><li>把请求的字返回CPU</li></ol></li></ol><h3><span id="映射功能">映射功能</span></h3><p>Cache的行远少于主存的块，所以需要一种算法把主存的块映射到Cache的行中，并且需要一种方法确定主存储器的哪一块当前占用了Cache的行</p><p>通常采用三种技术：</p><ol><li>直接映射</li><li>关联映射</li><li>组关联映射</li></ol><hr><ul><li><p>直接映射</p><p>把主存储器的每一块映射到相关的固定的行中。</p><script type="math/tex; mode=display">i=j \ mod \ m</script><p>i=Cache行号</p><p>j=主存储器块号</p><p>m=Cache的行数</p></li></ul><p>因此，地址这样表示：</p><p>地址长度=（s+w）位</p><p>寻址单元个数=$2^{s+w}$个，即可以寻址这么多的字</p><p>块大小=行大小=2^w个字</p><p>主存的块数=2^s</p><p>Cache的行数m=2^r个</p><p>则标记的大小（s-r）位</p><blockquote><p>例如</p><p>Cache有四行，每行8个字</p><p>主存有128个字，则主存有16个块</p><p>直接映射后Cache的每一行负责4个块</p><p>那么地址的长度为7位</p><div class="table-container"><table><thead><tr><th>Tag</th><th>Line</th><th>Word</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>3</td></tr></tbody></table></div><p>Word表示在块中寻找字</p><p>Line表示选择Cache的行</p><p>Tag表示哪个块占用了行</p></blockquote><ul><li><p>关联映射</p><p>允许主存储器中的每一个块装入Cache的任何一行中</p><p>关联映射把存储器地址解释为tag和word域</p><p>tag唯一标识主存储块</p><p>​    为确定某块是否在cache中，必须对cache中每一行的标记位进行检查</p></li></ul><p>于是地址这样表示：</p><p>地址长度=（s+w）位</p><p>寻址单元数=$2^{s+w}$个，即可以表示这么多的字</p><p>块大小=行大小=2^w个，即每行或者每块有这么多个字</p><p>主存的块数=2^s个</p><p>Cache的行数不确定</p><p>标记位=s</p><p>标记位完全由块数确定</p><blockquote><p>例如</p><p>Cache有4行，每行8个字</p><p>主存储器有128个字，即有16个块</p><div class="table-container"><table><thead><tr><th>Tag</th><th>Word</th></tr></thead><tbody><tr><td>4</td><td>3</td></tr></tbody></table></div><p>Word用于在行中找到相应的字</p><p>Tag用于在主存中找到相应的块</p></blockquote><ul><li><p>组关联映射</p><p>组关联映射直接体现关联映射和直接映射的优点</p><p>将Cache分为v个组，每个组有k行</p><p>​    Cache的行数 m=v×k</p><p>​    Cache组号i=j mod v</p><p>把存储器地址分为三个域：标记、组和字</p></li></ul><p>于是地址这样表示：</p><p>​    地址长度=（s+w）位</p><p>​    寻址单元数=$2^{s+w}$个字，即一共有这么多个字</p><p>​    块大小=行大小=2^w</p><p>​    每组的行数=k</p><p>​    组数v=2^d</p><p>​    Cache的行数=kv</p><p>标记大小=（s-d）位</p><blockquote><p>例如</p><p>Cache有4行，可以分成两组，每组两行</p><p>每行有8个字</p><p>主存储器有128个字，那么就有16个块</p><p>16个块，可以分成8个组</p><div class="table-container"><table><thead><tr><th>Tag</th><th>Set</th><th>Word</th></tr></thead><tbody><tr><td>3</td><td>1</td><td>3</td></tr></tbody></table></div><p>Word在块或者行里面找字</p><p>Set在组里面可以找到对应的块</p><p>Tag在Cache中找到对应哪一个组</p></blockquote><h3><span id="替换策略">替换策略</span></h3><p>当主存中新的块被写入Cache时，原先的行的内容需要被覆盖掉。</p><p>对于直接映射，一个特定的块有一个固定的行</p><p>而对于关联映射和组关联映射，需要有一种替换策略</p><ul><li>最近最少（LRU）：替换掉那些在Cache中驻留时间最长且未被引用过的块</li><li>先进先出（FIFO）：直接替换掉在Cache中停留时间最长的块</li><li>最不经常使用（LFU）</li><li>随机选取</li></ul><h3><span id="写策略">写策略</span></h3><p>在Cache中的一行被取代时，必须考虑它是否在Cache中被修改过。</p><p>如果没有修改，那么直接覆盖。</p><p>如果被修改过了，那么主存中的内容必须被更新。</p><ul><li><p>写直达</p><p>每当cache被修改时，立即对主存进行写操作</p></li><li><p>写回</p><p>只在Cache中进行修改，修改时设置与此行相关的修改位，因此，当某个块被替换的时候，当且仅当修改位被修改时，才将它写回主存储器</p></li></ul><h2><span id="磁盘">磁盘</span></h2><h3><span id="磁盘读写机制">磁盘读写机制</span></h3><p>数据的记录及读出通过一个叫做磁头的的导电线圈进行</p><h2><span id="内存管理">内存管理</span></h2><p>过去，只有操作系统在内存里面</p><p>现今，操作系统和多个程序都在里面</p><ul><li>为了减少处理器等待I/O的停顿</li></ul><p>三种内存管理模式：</p><ul><li>实模式</li><li>分段式</li><li>段页式</li></ul><h3><span id="分区">分区</span></h3><p>操作系统占内存的固定部分，其余部分分区后分配给多个进程使用</p><ul><li><p>定长分区</p><p>长度不等</p><p>当一个进程调入主存的时候，分配给它一个能容纳它的最小的分区</p></li><li><p>变长分区</p><p>当一个进程调入主存的时候，分配的分区和进程需要的大小一致</p></li></ul><h3><span id="分页">分页</span></h3><p>定长分区和不定长分区的效率都很低，所以采用分页</p><ul><li><p>原理</p><p>把存储器分成固定长的比较小的存储块，把每个进程也划分成小的固定长的块。</p><p>一个程序的程序块分配到进程的存储块中。</p><p>即把页放入页帧。</p></li><li><p>地址</p><p>由操作系统为每个进程保存一个页表，页表记录了进程每一个页的页帧地址。</p><p>在程序中，每个逻辑地址由一个页号和页中相对地址组成。</p><p>遇到一个逻辑地址的时候（页号+相对地址），处理器把它变成物理地址（页帧号+相对地址）</p></li></ul><h3><span id="请求分页">请求分页</span></h3><p>请求分页表示每个进程的页只在需要的时候被调用。</p><p>于是，在任何时候，只有任一给定进程的小部分页在存储器中，因而有更多的进程能驻留在存储器中。</p><h3><span id="页表结构">页表结构</span></h3><p>从存储器中读取一个字的基本机制是：使用页表把虚拟或者逻辑地址转换成物理地址。</p><ul><li><p>保存位置</p><p>由于页表是可变长的，所以我们不能把它保存在寄存器中，而必须把它保存在主存中。</p><p>当运行一个特定进程的时候，寄存器保存这个进程页表的初始地址。</p></li></ul><h3><span id="转换后缓缓存器">转换后缓缓存器</span></h3><p>每次虚拟存储器的访问都能产生两次物理存储器存取，一次是获取相应的页表项，一次是获取所需的数据。因此，即使一个简单的虚拟存储器方案也将使存储器的存取时间加倍。</p><p>所以，许多存储器都采用一个特殊的Cache来保存最近使用的那些页表项。</p><h3><span id="实模式">实模式</span></h3><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;span id=&quot;computer-organization-and-architecture&quot;&gt;Computer Organization and Architecture&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span id=&quot;introduction&quot;&gt;Introduc</summary>
      
    
    
    
    <category term="Computer" scheme="http://chenzihong.com/categories/Computer/"/>
    
    
    <category term="Computer" scheme="http://chenzihong.com/tags/Computer/"/>
    
    <category term="Computer components" scheme="http://chenzihong.com/tags/Computer-components/"/>
    
  </entry>
  
  <entry>
    <title>对Hexo官方文档的研究</title>
    <link href="http://chenzihong.com/2020/11/26/Hexo%20research/"/>
    <id>http://chenzihong.com/2020/11/26/Hexo%20research/</id>
    <published>2020-11-26T09:31:56.000Z</published>
    <updated>2020-12-12T03:18:15.310Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><blockquote><p><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></p></blockquote><h2><span id="为何选择hexo">为何选择Hexo</span></h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>先前的个人主页用的是WordPress搭建，当我面对它稀疏可怜的对页面掌控权以及各类收费主题与插件时，果断选择了换用Hexo构建我的博客网站。</p><p>WordPress更加适合对页面修改没有太多要求，希望轻松发布文章的文字工作者。</p><h2><span id="hexo安装">Hexo安装</span></h2><ol><li>node.js</li><li>git</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自动生成hexo博客目录：</p><pre class="line-numbers language-none"><code class="language-none">.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>_config.yml 配置文件</p></li><li><p>package.json 应用程序信息</p></li><li><p>scaffolds <a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。新建文章时，Hexo 会根据 scaffold 来建立文件</p></li><li><p>source 存放用户资源。<code>_post</code>存放文章，其他<code>_</code>开头的文件夹将会被忽略</p></li><li>themes 主题文件夹</li></ul><h2><span id="hexo配置">Hexo配置</span></h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;https://hexo.io/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/&quot;&gt;Hexo官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    <category term="Beginning" scheme="http://chenzihong.com/categories/Beginning/"/>
    
    
    <category term="Hexo" scheme="http://chenzihong.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown之下的数学公式</title>
    <link href="http://chenzihong.com/2020/11/20/math%20formula/"/>
    <id>http://chenzihong.com/2020/11/20/math%20formula/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-12-12T03:15:09.718Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="配置">配置</span></h2><h3><span id="mathjax">mathjax</span></h3><p><strong>MathJax</strong>是一个开源，基于<strong>Ajax</strong>技术的数学表达式显示解决方案。它能够在HTMl页面中高质量的显示<strong>LaTeX</strong>和<strong>MathML</strong>数学符号</p><h3><span id="配置方法">配置方法</span></h3><ul><li>使用官方推荐的 MathJax 的CDN( 内容分发网络 ) 进行调用</li><li>使用针对不同平台开发的 MathJax 插件</li><li>本地安装 MathJax 的内容然后调用</li></ul><h2><span id="基本语法">基本语法</span></h2><ul><li>正文(inline)中的LaTeX公式用<code>\$...\$</code>定义</li><li>单独显示(display)的LaTeX公式用<code>\$\$...\$\$</code>定义，此时公式居中并放大显示</li></ul><h2><span id="修饰">修饰</span></h2><ul><li><p>上下标</p><p>使用<strong><code>^</code></strong>来表示上标，<strong><code>_</code></strong>来表示下标，同时如果上下标的内容多于一个字符，可以使用<strong><code>&#123;&#125;</code></strong>来将这些内容括起来当做一个整体</p><p>如</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">x &#x3D; a_1^n + a_&#123;23&#125;^n + a_&#123;4&#125;^n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>  呈现为</p><script type="math/tex; mode=display">  x = a_1^n + a_{23}^n + a_{4}^n</script><ul><li><p>矢量</p><p>在公式之前加上vec，如\vec a呈现为$\vec a$</p><p>另一种箭头在公式之前加上overright，如\overrightarrow{ab}呈现为$\overrightarrow{ab}$</p></li></ul><h2><span id="希腊字母">希腊字母</span></h2><ul><li>小写</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">公式</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center">\alpha</td><td style="text-align:center">$\alpha$</td></tr><tr><td style="text-align:center">\bata</td><td style="text-align:center">$\beta$</td></tr><tr><td style="text-align:center">\gamma</td><td style="text-align:center">$\gamma$</td></tr><tr><td style="text-align:center">\epsilon</td><td style="text-align:center">$\epsilon$</td></tr><tr><td style="text-align:center">\eta</td><td style="text-align:center">$\eta$</td></tr><tr><td style="text-align:center">\iota</td><td style="text-align:center">$iota$</td></tr><tr><td style="text-align:center">\lambda</td><td style="text-align:center">$\lambda$</td></tr><tr><td style="text-align:center">\nu</td><td style="text-align:center">$\nu$</td></tr><tr><td style="text-align:center">\pi</td><td style="text-align:center">$\pi$</td></tr><tr><td style="text-align:center">\sigma</td><td style="text-align:center">$\sigma$</td></tr><tr><td style="text-align:center">\upsilon</td><td style="text-align:center">$\upsilon$</td></tr><tr><td style="text-align:center">\chi</td><td style="text-align:center">$\chi$</td></tr><tr><td style="text-align:center">\omega</td><td style="text-align:center">$\omega$</td></tr><tr><td style="text-align:center">\delta</td><td style="text-align:center">$\delta$</td></tr><tr><td style="text-align:center">\zeta</td><td style="text-align:center">$\zeta$</td></tr><tr><td style="text-align:center">\theta</td><td style="text-align:center">$\theta$</td></tr><tr><td style="text-align:center">\kappa</td><td style="text-align:center">$\kappa$</td></tr><tr><td style="text-align:center">\mu</td><td style="text-align:center">$\mu$</td></tr><tr><td style="text-align:center">\xi</td><td style="text-align:center">$\xi$</td></tr><tr><td style="text-align:center">\rho</td><td style="text-align:center">$\rho$</td></tr><tr><td style="text-align:center">\tau</td><td style="text-align:center">$\tau$</td></tr><tr><td style="text-align:center">\phi</td><td style="text-align:center">$\phi$</td></tr><tr><td style="text-align:center">\psi</td><td style="text-align:center">$\psi$</td></tr></tbody></table></div><ul><li>大写</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">公式</th><th style="text-align:center">显示</th></tr></thead><tbody><tr><td style="text-align:center">\Gamma</td><td style="text-align:center">$\Gamma$</td></tr><tr><td style="text-align:center">\Iota</td><td style="text-align:center">$Iota$</td></tr><tr><td style="text-align:center">\Lambda</td><td style="text-align:center">$\Lambda$</td></tr><tr><td style="text-align:center">\Pi</td><td style="text-align:center">$\Pi$</td></tr><tr><td style="text-align:center">\Sigma</td><td style="text-align:center">$\Sigma$</td></tr><tr><td style="text-align:center">\Upsilon</td><td style="text-align:center">$\Upsilon$</td></tr><tr><td style="text-align:center">\Omega</td><td style="text-align:center">$\Omega$</td></tr><tr><td style="text-align:center">\Delta</td><td style="text-align:center">$\Delta$</td></tr><tr><td style="text-align:center">\Theta</td><td style="text-align:center">$\Theta$</td></tr><tr><td style="text-align:center">\Xi</td><td style="text-align:center">$\Xi$</td></tr><tr><td style="text-align:center">\Phi</td><td style="text-align:center">$\Phi$</td></tr><tr><td style="text-align:center">\Psi</td><td style="text-align:center">$\Psi$</td></tr></tbody></table></div><ul><li><p>斜体</p><p>在公式之前加上var，例如\varGamma呈现为$\varGamma$</p></li></ul><h2><span id="数学运算">数学运算</span></h2><ul><li>四则运算</li></ul><div class="table-container"><table><thead><tr><th>运算</th><th>公式</th><th>显示</th></tr></thead><tbody><tr><td>加减</td><td>\pm</td><td>$\pm$</td></tr><tr><td>减加</td><td>\mp</td><td>$\mp$</td></tr><tr><td>乘法</td><td>\times</td><td>$\times$</td></tr><tr><td>点乘</td><td>\cdot</td><td>$\cdot$</td></tr><tr><td>星乘</td><td>\ast</td><td>$\ast$</td></tr><tr><td>除法</td><td>\div</td><td>$\div$</td></tr><tr><td>分式</td><td>\frac{分子}{分母}</td><td>$\frac{x+y}{a+b}$</td></tr><tr><td>根式</td><td>\sqrt{x}{y}</td><td>$\sqrt{x}{y}$</td></tr></tbody></table></div><ul><li>高级运算</li></ul><div class="table-container"><table><thead><tr><th>运算</th><th>公式</th><th>显示</th></tr></thead><tbody><tr><td>求和</td><td>\sum_{i=1}^n{a_i}</td><td>$\sum_{i=1}^n{a_i}$</td></tr><tr><td>极限</td><td>\lim_{x\to 0}</td><td>$lim_{x\to 0}$</td></tr><tr><td>积分</td><td>\int_0^\infty{f(x)dx}</td><td>$\int_0^\infty{f(x)dx}$</td></tr><tr><td>多重积分</td><td>\iint</td><td>$\iint$</td></tr><tr><td>累乘</td><td>\prod</td><td>$\prod$</td></tr><tr><td>并集</td><td>\bigcup</td><td>$\bigcup$</td></tr><tr><td>交集</td><td>\bigcap</td><td>$bigcap$</td></tr></tbody></table></div><h2><span id="函数">函数</span></h2><div class="table-container"><table><thead><tr><th>函数名</th><th>公式</th><th>显示</th></tr></thead><tbody><tr><td>正弦</td><td>\sin x</td><td>$\sin x$</td></tr><tr><td>对数</td><td>\ln x</td><td>$\ln x$</td></tr><tr><td>最大值</td><td>\max (A,B,C)</td><td>$\max (A,B,C)$</td></tr><tr><td>以此类推</td><td>……</td><td>……</td></tr></tbody></table></div><h2><span id="矩阵">矩阵</span></h2><ul><li>基本方法</li></ul><p>起始标记<code>\begin&#123;matrix&#125;</code>，结束标记<code>\end&#123;matrix&#125;</code>，换行标记<code>\\</code>，元素分隔标记<code>&amp;</code></p><p>如</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">$$\begin&#123;matrix&#125;1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\\\end&#123;matrix&#125;$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>呈现为</p><script type="math/tex; mode=display">\begin{matrix}1&0&0\\0&1&0\\0&0&1\\\end{matrix}</script><ul><li>矩阵边框</li></ul><div class="table-container"><table><thead><tr><th>边框名</th><th>公式</th><th>显示</th></tr></thead><tbody><tr><td>小括号</td><td>pmatrix</td><td>$\begin{pmatrix}\end{pmatrix}$</td></tr><tr><td>中括号</td><td>bamatrix</td><td>$\begin{bmatrix}\end{bmatrix}$</td></tr><tr><td>大括号</td><td>Bmatrix</td><td>$\begin{Bmatrix}\end{Bmatrix}$</td></tr><tr><td>单竖线</td><td>vmatrix</td><td>$\begin{vmatrix}\end{vmatrix}$</td></tr><tr><td>双竖线</td><td>Vmatrix</td><td>$\begin{Vmatrix}\end{Vmatrix}$</td></tr></tbody></table></div><ul><li>省略号</li></ul><p>横省略号：<code>\cdots</code></p><p>竖省略号：<code>\vdots</code></p><p>斜省略号：<code>\ddots</code></p><p>如</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">$$\begin&#123;bmatrix&#125;&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\\end&#123;bmatrix&#125;$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>呈现为</p><script type="math/tex; mode=display">\begin{matrix}{a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\{a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{m1}}&{a_{m2}}&{\cdots}&{a_{mn}}\\\end{matrix}</script><h2><span id="方程组">方程组</span></h2><ul><li>需要cases环境：起始、结束处以{cases}声明</li></ul><p>如</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex">$$\begin&#123;cases&#125;a_1x+b_1y+c_1z&#x3D;d_1\\a_2x+b_2y+c_2z&#x3D;d_2\\a_3x+b_3y+c_3z&#x3D;d_3\\\end&#123;cases&#125;$$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>呈现为</p><script type="math/tex; mode=display">\begin{cases}a_1x+b_1y+c_1z=d_1\\a_2x+b_2y+c_2z=d_2\\a_3x+b_3y+c_3z=d_3\\\end{cases}</script><h2><span id="结束">结束</span></h2><p>整理就到这里了，以后还会有补充的。</p><p>主要为了方便在Hexo的写作，顺带学习一点Latex的语法。</p><h2><span id="参考">参考</span></h2><p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax tutorial</a></p><p><a href="https://latex.codecogs.com/eqneditor/editor.php">Latex公式在线查看</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2&gt;&lt;span id=&quot;配置&quot;&gt;配置&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;mathjax&quot;&gt;mathjax&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;MathJax&lt;/strong&gt;是一个开源，基于&lt;strong&gt;Ajax&lt;/strong&gt;技术的数学表达式显示</summary>
      
    
    
    
    <category term="Beginning" scheme="http://chenzihong.com/categories/Beginning/"/>
    
    
    <category term="Algebra" scheme="http://chenzihong.com/tags/Algebra/"/>
    
    <category term="Markdown" scheme="http://chenzihong.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>看不完的线性代数</title>
    <link href="http://chenzihong.com/2020/11/18/linear%20algebra/"/>
    <id>http://chenzihong.com/2020/11/18/linear%20algebra/</id>
    <published>2020-11-17T16:00:00.000Z</published>
    <updated>2020-12-05T06:21:28.849Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这篇文章用以记录学习线性代数的心路历程</p></blockquote><p>欢迎大家与我 <code>讨论</code> 以及 <code>留言</code></p><p>(<a href="http://open.163.com/newview/movie/courseintro?newurl=%2Fspecial%2Fopencourse%2Fdaishu.html">MIT线性代数课程</a>)</p><h2><span id="目录">目录</span></h2><!-- toc --><ul><li><a href="#二阶-三阶与n阶行列式">二阶、三阶与n阶行列式</a><ul><li><a href="#什么是行列式">什么是行列式</a></li><li><a href="#二阶行列式">二阶行列式</a></li><li><a href="#三阶行列式">三阶行列式</a></li><li><a href="#n阶行列式">n阶行列式</a></li></ul></li><li><a href="#矩阵">矩阵</a><ul><li><a href="#矩阵的几何运算">矩阵的几何运算</a></li><li><a href="#初等变换">初等变换</a></li><li><a href="#可逆矩阵">可逆矩阵</a></li><li><a href="#矩阵的秩">矩阵的秩</a></li></ul></li><li><a href="#向量">向量</a><ul><li><a href="#向量组的等价">向量组的等价</a></li><li><a href="#线性相关与线性无关">线性相关与线性无关</a></li><li><a href="#线性相关性与矩阵秩的关系">线性相关性与矩阵秩的关系</a></li><li><a href="#极大无关组与向量组的秩">极大无关组与向量组的秩</a></li></ul></li><li><a href="#线性方程组解的结构">线性方程组解的结构</a></li><li><a href="#矩阵的特征值与特征向量">矩阵的特征值与特征向量</a><ul><li><a href="#相似矩阵">相似矩阵</a></li><li><a href="#迹">迹</a></li></ul></li></ul><!-- tocstop --><h2><span id="二阶-三阶与n阶行列式">二阶、三阶与n阶行列式</span></h2><h3><span id="什么是行列式">什么是行列式</span></h3><p>​    行列式是一种非常有用的数学工具，是线性代数的一个基本内容。</p><h3><span id="二阶行列式">二阶行列式</span></h3><p>​    一般来说，我们解二元一次方程组（方程组1.1），采用消元法：</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2=b_1 \\a_{21}x_1+a_{22}x_2=b_2\end{cases}</script><p>​    有解：</p><script type="math/tex; mode=display">\begin{cases}x_1=\frac{b_1a_{22}-b_2a_{11}}{a_{11}a_{22}-a_{12}a_{21}} \\x_2=\frac{b_2a_{11}-b_1a_{21}}{a_{11}a_{22}-a_{12}a_{21}}\end{cases}</script><p>很容易发现形式上的统一，所以我们引入新的记号来表示。</p><blockquote><p>定义1.1.1</p><p>将四个可以进行乘法和加法运算的元素a,b,c,d排成两行两列：</p><script type="math/tex; mode=display">\begin{vmatrix}a&b \\c&d\end{vmatrix}=ad-bc</script><p>称为<em>二阶行列式</em>。</p></blockquote><p>二阶行列式事实上是一个算式，即左上角与右下角的元素相乘后减去右上角与左下角的元素相乘。</p><p>​    记：</p><script type="math/tex; mode=display">\Delta=\begin{vmatrix}a_{11}&a_{12} \\a_{21}&a_{22} \end{vmatrix}\\\Delta_1=\begin{vmatrix}b_{1}&a_{12} \\b_{2}&a_{22} \end{vmatrix}\\\Delta_2=\begin{vmatrix}a_{11}&b_{1} \\a_{21}&b_{2} \end{vmatrix}</script><p>​    有如下定理：</p><blockquote><p>定理1.1.1</p><p>对方程组1.1有如下结论：</p><p>（1）若</p><script type="math/tex; mode=display">\Delta \neq0</script><p>则方程组（1.1）有唯一的解</p><script type="math/tex; mode=display">x_1=\frac{\Delta_1}\Delta \\x_2=\frac{\Delta_2}\Delta</script><p>（2）若</p><script type="math/tex; mode=display">\Delta=0 \\\Delta_1，\Delta_2不全为0</script><p>则方程组（1.1）无解</p><p>（3）若</p><script type="math/tex; mode=display">\Delta=\Delta_1=\Delta_2=0</script><p>则方程组（1.1）有无穷多组解</p></blockquote><h3><span id="三阶行列式">三阶行列式</span></h3><blockquote><p>定义1.1.2</p><p>设有9个可以进行乘法和加法的元素排成三行三列，用记号</p><script type="math/tex; mode=display">\begin{vmatrix}a&b&c \\d&e&f \\g&h&i\end{vmatrix}=aei-afh-bdi+bgf+cdh-ceg \\=a\begin{vmatrix}e&f \\h&i\end{vmatrix}-b\begin{vmatrix}d&f \\g&i\end{vmatrix}+c\begin{vmatrix}d&e \\g&h\end{vmatrix}</script><p>表示，并称之为<strong>三阶行列式</strong></p><p>计算规则：</p><p>1）任取一行（列）</p><p>2）用这行（列）的每个元素 × 除开此元素所在行与列剩下的行列式 × $（-1）^{i+j}$，i是行号，j是列号</p><p>3）相加</p></blockquote><p>同样，三阶行列式可以应用于三元一次方程组（方程组1.2）</p><script type="math/tex; mode=display">\begin{cases}a_{11}x_1+a_{12}x_2+a_{13}x_3=b_1 \\a_{21}x_1+a_{22}x_2+a_{23}x_3=b_2 \\a_{31}x_1+a_{32}x_2+a_{33}x_3=b_3\end{cases}</script><p>​    记：</p><script type="math/tex; mode=display">\Delta=\begin{vmatrix}a_{11}&a_{12}&a_{13} \\a_{21}&a_{22}&a_{23} \\a_{31}&a_{32}&a_{33}\end{vmatrix}        \\\Delta_1=\begin{vmatrix}b_{1}&a_{12}&a_{13} \\b_{2}&a_{22}&a_{23} \\b_{3}&a_{32}&a_{33}\end{vmatrix}       \\\Delta_2=\begin{vmatrix}a_{11}&b_{1}&a_{13} \\a_{21}&b_{2}&a_{23} \\a_{31}&b_{3}&a_{33}\end{vmatrix}        \\\Delta_3=\begin{vmatrix}a_{11}&a_{12}&b_{1} \\a_{21}&a_{22}&b_{2} \\a_{31}&a_{32}&b_{3}\end{vmatrix}</script><p>​    有定理：</p><blockquote><p>定理1.1.2</p><p>对方程组1.2有如下结论：</p><p>(1) 若</p><script type="math/tex; mode=display">\Delta \neq0</script><p>则方程组（1.1）有唯一的解</p><script type="math/tex; mode=display">x_1=\frac{\Delta_1}\Delta \\x_2=\frac{\Delta_2}\Delta \\x_3=\frac{\Delta_3}\Delta</script><p>(2) 若</p><script type="math/tex; mode=display">\Delta=0 \\\Delta_1，\Delta_2，\Delta_3不全为0</script><p>则方程组（1.2）无解</p><p>(3) 若</p><script type="math/tex; mode=display">\Delta=\Delta_1=\Delta_2=0</script><p>则方程组（1.1）可能无解也可能有无穷多组解</p></blockquote><hr><p>二阶三阶行列式有许多特别的性质，然而这些性质在行列式中是共通的，我们不妨放在n阶行列式中来看。</p><h3><span id="n阶行列式">n阶行列式</span></h3><blockquote><p>定义1.2.1</p><script type="math/tex; mode=display">D_n=\begin{vmatrix}a_{11}&a_{12}&\cdots&a_{1n} \\a_{21}&a_{22}&\cdots&a_{2n} \\\vdots&\vdots&\ddots&\vdots \\a_{n1}&a_{n2}&\cdots&a_{nn}\end{vmatrix} \\=a_{11}A_{11}+a_{12}A_{12}+\cdots+a_{1n}A_{1n} \\=\Sigma_{j=1}^na_{1j}A_{1j}</script><p>其中</p><script type="math/tex; mode=display">A_{ij}=(-1)^{i+j}M_{ij} \\M_{ij}$是a_{ij}的余子式,即除去第i行，第j列剩下的元素组成的行列式 \\A_{ij}被称为代数余子式</script></blockquote><p>几个特别的行列式：</p><ul><li>上三角行列式</li></ul><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&a_{12}&\cdots&a_{1n} \\0&a_{22}&\cdots&a_{2n} \\\vdots&\vdots&\ddots&\vdots \\0&0&\cdots&a_{nn}\end{vmatrix}</script><ul><li>下三角行列式</li></ul><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&0&\cdots&0 \\a_{21}&a_{22}&\cdots&0 \\\vdots&\vdots&\ddots&\vdots \\a_{n1}&a_{n2}&\cdots&0\end{vmatrix}</script><ul><li>对角行列式</li></ul><script type="math/tex; mode=display">\begin{vmatrix}a_{11}&0&\cdots&0 \\0&a_{22}&\cdots&0 \\\vdots&\vdots&\ddots&\vdots \\0&0&\cdots&a_{nn}\end{vmatrix}</script><ul><li>反对称行列式</li></ul><script type="math/tex; mode=display">D_n=\begin{vmatrix}a_{11}&a_{12}&\cdots&a_{1n} \\-a_{11}&a_{22}&\cdots&a_{2n} \\\vdots&\vdots&\ddots&\vdots \\-a_{1n}&-a_{2n}&\cdots&a_{nn}\end{vmatrix}</script><p>容易证明：奇数阶的反对称行列式都为0</p><blockquote><p>定义1.2.3</p><p>转置行列式</p><script type="math/tex; mode=display">设A=\begin{vmatrix}a_{11}&a_{12}&\cdots&a_{1n} \\a_{21}&a_{22}&\cdots&a_{2n} \\\vdots&\vdots&\ddots&\vdots \\a_{n1}&a_{n2}&\cdots&a_{nn}\end{vmatrix}\\A^{'}=\begin{vmatrix}a_{11}&a_{21}&\cdots&a_{n1} \\a_{12}&a_{22}&\cdots&a_{n2} \\\vdots&\vdots&\ddots&\vdots \\a_{1n}&a_{2n}&\cdots&a_{nn}\end{vmatrix}</script><p>则A’为A的<em>转置行列式</em>，即行与列交换所得，也可以用$A^T$表示。</p></blockquote><hr><p>行列式常用的几个性质：</p><blockquote><p>定理1.2.1</p><p>行列式与它的转置行列式的值相等</p><p>定理1.2.2</p><p>对调两行（列）的位置，行列式的值相差一个符号</p><p>推论1.2.3</p><p>两行（列）相等的行列式的值为0</p><p>推论1.2.4</p><p>行列式可以按任意一行（列）展开</p><p>定理1.2.5</p><p>行列式任意一行（列）的公因子可以提出到行列式外</p><p>推论1.2.6</p><p>若行列式任意两行（列）对应成比例，则行列式的值为0</p><p>定理1.2.7</p><p>行列式可以拆分成两个行列式的和</p><p>定理1.2.8</p><p>将行列式任意一行（列）乘以系数k加到另一行上去，行列式的值不变。</p><p>定理1.2.9</p><p>行列式任一行（列）与另一行（列）的代数余子式乘积之和为0</p></blockquote><ul><li>n阶Vandermonde行列式</li></ul><script type="math/tex; mode=display">D_n=\begin{vmatrix}1&1&\cdots&1 \\x_{1}&x_{2}&\cdots&x_{n} \\\vdots&\vdots&\ddots&\vdots \\x_{1}^{n-1}&x_{2}^{n-1}&\cdots&x_{n}^{n-1}\end{vmatrix} \\=\prod_{1\leq i\leq j} (x_j-x_i)</script><ul><li>分块行列式乘法</li></ul><script type="math/tex; mode=display">\begin{vmatrix}A&0 \\*&B \\\end{vmatrix}=\begin{vmatrix}A&* \\0&B \\\end{vmatrix}=\begin{vmatrix}A\end{vmatrix}\begin{vmatrix}B \end{vmatrix} \\\begin{vmatrix}0&A \\B&* \\\end{vmatrix}=(-1)^{nm}\begin{vmatrix}A\end{vmatrix}\begin{vmatrix}B \end{vmatrix} \\</script><h2><span id="矩阵">矩阵</span></h2><ul><li>转置矩阵</li><li>方阵的行列式</li></ul><h3><span id="矩阵的几何运算">矩阵的几何运算</span></h3><ul><li><p>加法</p></li><li><p>数乘</p><p>×× 方阵的数乘与行列式</p><script type="math/tex; mode=display">若A是n阶方阵，k为任意数，则有\begin{vmatrix}kA\end{vmatrix}=k^n\begin{vmatrix}A\end{vmatrix}</script><p>对于方阵：</p><script type="math/tex; mode=display">\begin{vmatrix}AB\end{vmatrix}=\begin{vmatrix}A\end{vmatrix}\begin{vmatrix}B\end{vmatrix}</script></li><li><p>转置矩阵的性质</p></li></ul><h3><span id="初等变换">初等变换</span></h3><p>如果矩阵A经过有限次初等行变换得到矩阵B，称矩阵A和B<strong>行等价</strong></p><p>如果矩阵A经过有限次初等列变换得到矩阵B，称矩阵A和B<strong>列等价</strong></p><p>如果矩阵A经过有限次初等变换变成矩阵B，则称矩阵A和B<strong>等价</strong></p><h3><span id="可逆矩阵">可逆矩阵</span></h3><script type="math/tex; mode=display">基本性质：\\1.若A可逆，则A^{-1}也可逆 \\2.(kA)^{-1}=k^{-1}A^{-1} \\3.(A^T)^{-1}=(A^{-1})^T</script><h3><span id="矩阵的秩">矩阵的秩</span></h3><script type="math/tex; mode=display">r(A)是A的非零子式的最高阶数字  \\0\leq r(A) \leq min \{m,n\} \\r(A^T)=r(A) \\对于n阶方阵A，有r(A)=n \Leftrightarrow A为满秩矩阵 \Leftrightarrow \begin{vmatrix}A\end{vmatrix}\neq0\Leftrightarrow A非异</script><h2><span id="向量">向量</span></h2><h3><span id="向量组的等价">向量组的等价</span></h3><h3><span id="线性相关与线性无关">线性相关与线性无关</span></h3><ul><li><p>用定义判断</p></li><li><p>用向量之间的关系判断</p><blockquote><p>定理2.7.1</p><script type="math/tex; mode=display">向量组A:\alpha_1,\alpha_2,…，\alpha_m线性相关的充要条件是，向量组A中至少有一个向量可以由其他m-1个向量表示</script><p>定理2.7.2</p><script type="math/tex; mode=display">设向量组A：\alpha_1,\alpha_2,…，\alpha_r,线性无关，而向量组\alpha_1,\alpha_2,…，\alpha_r,\beta线性相关，\\则向量\beta可由向量组A线性表示，且表示方法唯一。</script></blockquote><h3><span id="线性相关性与矩阵秩的关系">线性相关性与矩阵秩的关系</span></h3><p>r个n维向量，线性相关的充要条件是r(A)&lt;r</p><blockquote><p>推论2.7.4</p><p>向量组的个数m&gt;维度n，则向量组线性相关</p><p>推论2.7.5</p><p>n个n维向量线性无关的充要条件是其行列式不为0</p></blockquote><h3><span id="极大无关组与向量组的秩">极大无关组与向量组的秩</span></h3><p>若A可由B线性表示，则必有r（A）≤r（B）</p><p>等价的向量组必有相同的秩</p><p>r（A+B）&lt;=r（A）+r（B）</p><p>r（AB）&lt;=r（A）</p><p>r（AB）&lt;=r（B）</p><p>AB为n阶，r（AB）大于等于r（A）+r（B）-n</p></li></ul><h2><span id="线性方程组解的结构">线性方程组解的结构</span></h2><h2><span id="矩阵的特征值与特征向量">矩阵的特征值与特征向量</span></h2><h3><span id="相似矩阵">相似矩阵</span></h3><blockquote><p>性质1</p><script type="math/tex; mode=display">若A～B，则\begin{vmatrix}A\end{vmatrix}=\begin{vmatrix}B\end{vmatrix}</script><p>定理4.2.3</p><p>相似矩阵具有相同的特征多项式，从而它们具有相同的特征值</p></blockquote><h3><span id="迹">迹</span></h3><blockquote><p>定义4.2.3</p><script type="math/tex; mode=display">tr（A）=\sum_{i=1}^na_{ii}</script><p>为矩阵A的<strong>迹</strong></p></blockquote><p>特征值的和为迹，特征值的积为行列式</p><p>相似矩阵具有相同的迹和相同的行列式</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这篇文章用以记录学习线性代数的心路历程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎大家与我 &lt;code&gt;讨论&lt;/code&gt; 以及 &lt;code&gt;留言&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(&lt;a href=&quot;http://open.163.com/newv</summary>
      
    
    
    
    <category term="Algebra" scheme="http://chenzihong.com/categories/Algebra/"/>
    
    
    <category term="Algebra" scheme="http://chenzihong.com/tags/Algebra/"/>
    
    <category term="Linear Algebra" scheme="http://chenzihong.com/tags/Linear-Algebra/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://chenzihong.com/2020/10/29/hello-world/"/>
    <id>http://chenzihong.com/2020/10/29/hello-world/</id>
    <published>2020-10-28T16:00:00.000Z</published>
    <updated>2020-12-12T03:16:33.968Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="Beginning" scheme="http://chenzihong.com/categories/Beginning/"/>
    
    
    <category term="Hexo" scheme="http://chenzihong.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
